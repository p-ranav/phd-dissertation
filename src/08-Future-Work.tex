\chapter{Summary and Future Work}
\label{chapter:conclusion}

% Summarize Contributions first
This thesis has presented an integrated timing analysis methodology for component-based distributed real-time embedded systems. The approach works by translating a design model of the target system i.e. a precise model of the software, hardware, and deployment into a Colored Petri net (CPN) and evaluating the system by performing state space analysis on the net. In the thesis, the DREMS component model is chosen as the target model for analysis. Aspects of the DREMS component e.g. the execution semantics of the component operation scheduler, the semantics of port interactions etc. are encoded as functions in Standard ML and integrated into the CPN model. User-defined properties of a DREMS component e.g. the component definition, the properties of component timers and ports, the connections between components etc. are parsed and translated into CPN tokens and injected into the generic model. Once injected, the complete CPN model is then analyzed using state space analysis queries. A state space is a directed graph, where the nodes represent states of existence of the system, and the edges between nodes represent transitions between the states of existence. State space analysis is the process of searching through the possible states of existence of the system to identify a state or a set of states where some system property is violated e.g. response time of some component operation has violated its timing specification. Not only is the CPN analysis model completely generated from the system design model, it is also capable of analyzing a variety of different system properties such as deadline violations, trigger-to-response times, deadlock freedom and CPU utilization. Scalability studies indicate that the model is capable of analyzing medium-to-large scale systems (tested up to a 100 component assembly) and experimental evaluation shows that the predicted execution time bounds for component operations are conservative but close approximations of the real execution.

All of the results presented in this thesis make an important assumption about the network -- the network resources available to each component is much larger than the requirements of the application i.e. there are no buffering delays on the network queues when components periodically produce data. The current analysis model, in this respect, is quite lacking. When a component publishes a message on a topic, the analysis immediately generates a reception message that waits to enqueue on the receiver's message queue. In reality, this interaction could be a lot more involved -- the published message is sent to the kernel network queue on the sender's side and removed from this queue following a data production \emph{profile} i.e. available bandwidth as a function of time. When dequeued, the packets take a finite worst-case transmission time before being noticed on the receiver's side. The buffering delays on the sender's side and the transmission time on the network are completely ignored by the timing analysis model. In order to improve on this design, we have attempted to integrate existing Network Calculus-based analysis methods \cite{ISIS_F6_CYPHY:14} into our CPN. Specifically, a place is added to model the \emph{Network Queue} and a \emph{Dequeue} transition fires when the network is ready to transport more packets from the sender. The dequeuing follows a strict network profile and ceases transmission when the data production rate is larger than the available bandwidth. 

Also, the business logic model i.e. the model of execution code in a component operation is quite simplistic. This model is able to represent local non-blocking code blocks, DREMS-style interaction patterns, and bounded loops of either. The model is however, unable to represent conditional statements that rely on local variables. This is a disadvantage as the resultant analysis is unable to accurately represent the execution behavior of the runtime code. Many if not most distributed real-time embedded scenarios in real-life exhibit conditional behavior that are driven by runtime state e.g. robotic applications that transition from one state of operation to another at runtime. The business logic of such operations cannot be fully represented by the current model and this has lead to gross overestimates in execution time behavior. Such over-estimation makes the analysis results useless as no operation scheduling may be calculated as feasible. Thus, the business logic model, and its integration into the analysis model both require improvement in order to support a wider range of execution scenarios. 

