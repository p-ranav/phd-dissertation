Figure \hfill Page

\addvspace {10\p@ }
\contentsline {figure}{\numberline {1}{\ignorespaces Embedded Software Development Lifecycle Comparison\relax }}{4}{figure.1}
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {2}{\ignorespaces Sample Petri Net, reprinted from \cite {peterson1977petri}\relax }}{24}{figure.2}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3}{\ignorespaces DREMS Component\relax }}{35}{figure.3}
\contentsline {figure}{\numberline {4}{\ignorespaces Component Operation Execution Semantics: This figure shows the effects of the ROSMOD component scheduling on an incoming operation request. $t\_{req}$ represents the arrival time of a remote request. $t\_{wait}$ is the wait time of this request in the message queue while the current operation is still executing. $t\_{timer\_cmpl}$ is the time stamp at which the current operation completes executing. At this time, the remote request is finally scheduled for execution. $t\_{req\_cmpl}$ is the time stamp at which the remote request completes. The execution time, $t\_{exec}$ of this request is calculated as the difference in time stamps between $t\_{req\_cmpl}$ and $t\_{req}$.\relax }}{37}{figure.4}
\contentsline {figure}{\numberline {5}{\ignorespaces Sample Temporal Partition Schedule with Hyperperiod = 300 ms\relax }}{39}{figure.5}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {6}{\ignorespaces Colored Petri Net Analysis Model\relax }}{45}{figure.6}
\contentsline {figure}{\numberline {7}{\ignorespaces Analysis Model - Structural Aspects\relax }}{46}{figure.7}
\contentsline {figure}{\numberline {8}{\ignorespaces Temporal Partition Schedule Data Structure\relax }}{48}{figure.8}
\contentsline {figure}{\numberline {9}{\ignorespaces Component Thread Execution Cycle\relax }}{49}{figure.9}
\contentsline {figure}{\numberline {10}{\ignorespaces Component Operation Scheduling Cycle\relax }}{51}{figure.10}
\contentsline {figure}{\numberline {11}{\ignorespaces RMI Application\relax }}{52}{figure.11}
\contentsline {figure}{\numberline {12}{\ignorespaces RMI Application - Client Timer Operation\relax }}{53}{figure.12}
\contentsline {figure}{\numberline {13}{\ignorespaces RMI Application - Server Operation\relax }}{54}{figure.13}
\contentsline {figure}{\numberline {14}{\ignorespaces Operation Induction\relax }}{55}{figure.14}
\contentsline {figure}{\numberline {15}{\ignorespaces Operation Induction Token\relax }}{55}{figure.15}
\contentsline {figure}{\numberline {16}{\ignorespaces Timer Operations\relax }}{56}{figure.16}
\contentsline {figure}{\numberline {17}{\ignorespaces Modeling the Business Logic of Component Operations\relax }}{59}{figure.17}
\contentsline {figure}{\numberline {18}{\ignorespaces Sample Business Logic Model\relax }}{61}{figure.18}
\contentsline {figure}{\numberline {19}{\ignorespaces CPN Business Logic Representation\relax }}{62}{figure.19}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {20}{\ignorespaces Bounded State Space for a Multi-component Timer example -- The component threads have the same real-time priority and are executed in the same device. Each component is triggered with a 100 Hz periodic timer and all three timers are synchronized to illustrate non-determinism. The round robin scheduling quantum is set to 4 milliseconds. 'Mark' is a state space query function that provides the \emph {marking} of a place in a particular state space node.\relax }}{65}{figure.20}
\contentsline {figure}{\numberline {21}{\ignorespaces SearchNodes function provided by CPNTools\relax }}{66}{figure.21}
\contentsline {figure}{\numberline {22}{\ignorespaces Deadline Violation Observer place\relax }}{68}{figure.22}
\contentsline {figure}{\numberline {23}{\ignorespaces A Clock Token with Temporal Partitioning\relax }}{74}{figure.23}
\contentsline {figure}{\numberline {24}{\ignorespaces Dynamic Time Progression\relax }}{75}{figure.24}
\contentsline {figure}{\numberline {25}{\ignorespaces Structural Reductions in CPN\relax }}{77}{figure.25}
\contentsline {figure}{\numberline {26}{\ignorespaces Generated CPN model for a Distributed Application Deployment\relax }}{82}{figure.26}
\contentsline {figure}{\numberline {27}{\ignorespaces Sweep-Line Method\relax }}{83}{figure.27}
\contentsline {figure}{\numberline {28}{\ignorespaces Dead States Checking in a Component-based application\relax }}{84}{figure.28}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {29}{\ignorespaces Testbed Architecture\relax }}{87}{figure.29}
\contentsline {figure}{\numberline {30}{\ignorespaces ROSMOD Metamodel. Containment is specified from \emph {src} to \emph {dst} where the source has a containment attribute \emph {quantity}, meaning that \emph {quantity} objects of type \emph {src} can be contained in an object of type \emph {dst}. Pointers are specified as a one to one mapping from source to destination, using the name of the pointer. Sets allow for pointer containment. All objects contain a \emph {name} attribute of type \emph {string}, not shown for clarity. Note: the metamodel is used to create the ROSMOD Modeling Language, but users do not see or interact with it; it is used to enforce proper model creation semantics.\relax }}{90}{figure.30}
\contentsline {figure}{\numberline {31}{\ignorespaces Software Deployment Workflow\relax }}{96}{figure.31}
\contentsline {figure}{\numberline {32}{\ignorespaces Interpreting Execution Time Plots\relax }}{100}{figure.32}
\contentsline {figure}{\numberline {33}{\ignorespaces Experimental Observation: Client-Server Interactions\relax }}{101}{figure.33}
\contentsline {figure}{\numberline {34}{\ignorespaces CPN Analysis Results: Client-Server Interactions\relax }}{102}{figure.34}
\contentsline {figure}{\numberline {35}{\ignorespaces CPN Analysis Results: Client-Server Response Times in Bad Designs\relax }}{103}{figure.35}
\contentsline {figure}{\numberline {36}{\ignorespaces Experimental Observation: Publish-Subscribe Interactions\relax }}{104}{figure.36}
\contentsline {figure}{\numberline {37}{\ignorespaces CPN Analysis Results: Publish-Subscribe Interactions\relax }}{105}{figure.37}
\contentsline {figure}{\numberline {38}{\ignorespaces CPN Analysis Results: Time-triggered Publisher -- Periodicity Issues\relax }}{106}{figure.38}
\contentsline {figure}{\numberline {39}{\ignorespaces Trajectory Planner Test\relax }}{107}{figure.39}
\contentsline {figure}{\numberline {40}{\ignorespaces Experimental Observation: Trajectory Planner\relax }}{108}{figure.40}
\contentsline {figure}{\numberline {41}{\ignorespaces CPN Analysis Results: Trajectory Planner\relax }}{109}{figure.41}
\contentsline {figure}{\numberline {42}{\ignorespaces CPN Analysis - Sensor firing too frequently\relax }}{110}{figure.42}
\contentsline {figure}{\numberline {43}{\ignorespaces Experimental Observation: Periodic Timers\relax }}{111}{figure.43}
\contentsline {figure}{\numberline {44}{\ignorespaces CPN Analysis Results: Periodic Timers\relax }}{112}{figure.44}
\contentsline {figure}{\numberline {45}{\ignorespaces Long Running Operations - Timing Diagram\relax }}{114}{figure.45}
\contentsline {figure}{\numberline {46}{\ignorespaces Long Running Operation - Software Model\relax }}{115}{figure.46}
\contentsline {figure}{\numberline {47}{\ignorespaces Experimental Observation: Composed Component Assembly\relax }}{116}{figure.47}
\contentsline {figure}{\numberline {48}{\ignorespaces CPN Analysis Results: Composed Component Assembly\relax }}{117}{figure.48}
\addvspace {10\p@ }
\addvspace {10\p@ }
