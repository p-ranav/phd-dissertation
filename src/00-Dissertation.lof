Figure \hfill Page

\addvspace {10\p@ }
\contentsline {figure}{\numberline {1}{\ignorespaces Embedded Software Development Lifecycle Comparison\relax }}{4}{figure.1}
\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {2}{\ignorespaces Sample Petri Net, reprinted from \cite {peterson1977petri}\relax }}{27}{figure.2}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3}{\ignorespaces DREMS Component\relax }}{41}{figure.3}
\contentsline {figure}{\numberline {4}{\ignorespaces Component Operation Execution Semantics: This figure shows the effects of the ROSMOD component scheduling on an incoming operation request. $t\_{req}$ represents the arrival time of a remote request. $t\_{wait}$ is the wait time of this request in the message queue while the current operation is still executing. $t\_{timer\_cmpl}$ is the time stamp at which the current operation completes executing. At this time, the remote request is finally scheduled for execution. $t\_{req\_cmpl}$ is the time stamp at which the remote request completes. The execution time, $t\_{exec}$ of this request is calculated as the difference in time stamps between $t\_{req\_cmpl}$ and $t\_{req}$.\relax }}{43}{figure.4}
\contentsline {figure}{\numberline {5}{\ignorespaces Sample Temporal Partition Schedule with Hyperperiod = 300 ms\relax }}{45}{figure.5}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {6}{\ignorespaces Colored Petri Net Analysis Model\relax }}{51}{figure.6}
\contentsline {figure}{\numberline {7}{\ignorespaces Analysis Model - Structural Aspects\relax }}{52}{figure.7}
\contentsline {figure}{\numberline {8}{\ignorespaces Component Thread Execution Cycle\relax }}{54}{figure.8}
\contentsline {figure}{\numberline {9}{\ignorespaces RMI Application\relax }}{56}{figure.9}
\contentsline {figure}{\numberline {10}{\ignorespaces RMI Application - Client Timer Operation\relax }}{56}{figure.10}
\contentsline {figure}{\numberline {11}{\ignorespaces RMI Application - Server Operation\relax }}{57}{figure.11}
\contentsline {figure}{\numberline {12}{\ignorespaces Operation Induction\relax }}{58}{figure.12}
\contentsline {figure}{\numberline {13}{\ignorespaces Operation Induction Token\relax }}{59}{figure.13}
\contentsline {figure}{\numberline {14}{\ignorespaces Timer Operations\relax }}{60}{figure.14}
\contentsline {figure}{\numberline {15}{\ignorespaces Modeling the Business Logic of Component Operations\relax }}{63}{figure.15}
\contentsline {figure}{\numberline {16}{\ignorespaces Sample Business Logic Model\relax }}{64}{figure.16}
\contentsline {figure}{\numberline {17}{\ignorespaces CPN Business Logic Representation\relax }}{65}{figure.17}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {18}{\ignorespaces Bounded State Space for a Multi-component Timer example -- The component threads have the same real-time priority and are executed in the same device. Each component is triggered with a 100 Hz periodic timer and all three timers are synchronized to illustrate non-determinism. 'Mark' is a state space query function that provides the \emph {marking} of a place in a particular state space node.\relax }}{68}{figure.18}
\contentsline {figure}{\numberline {19}{\ignorespaces SearchNodes function provided by CPNTools\relax }}{69}{figure.19}
\contentsline {figure}{\numberline {20}{\ignorespaces Deadline Violation Observer place\relax }}{71}{figure.20}
\contentsline {figure}{\numberline {21}{\ignorespaces A Clock Token with Temporal Partitioning\relax }}{76}{figure.21}
\contentsline {figure}{\numberline {22}{\ignorespaces Dynamic Time Progression\relax }}{77}{figure.22}
\contentsline {figure}{\numberline {23}{\ignorespaces Structural Reductions in CPN\relax }}{79}{figure.23}
\contentsline {figure}{\numberline {24}{\ignorespaces Generated CPN model for a Distributed Application Deployment\relax }}{84}{figure.24}
\contentsline {figure}{\numberline {25}{\ignorespaces Sweep-Line Method\relax }}{85}{figure.25}
\contentsline {figure}{\numberline {26}{\ignorespaces Dead States Checking in a Component-based application\relax }}{86}{figure.26}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {27}{\ignorespaces Testbed Architecture\relax }}{91}{figure.27}
\contentsline {figure}{\numberline {28}{\ignorespaces Beaglebone Black Boards - Custom Mounting\relax }}{92}{figure.28}
\contentsline {figure}{\numberline {29}{\ignorespaces Constructed Testbed\relax }}{93}{figure.29}
\contentsline {figure}{\numberline {30}{\ignorespaces ROSMOD Metamodel. Containment is specified from \emph {src} to \emph {dst} where the source has a containment attribute \emph {quantity}, meaning that \emph {quantity} objects of type \emph {src} can be contained in an object of type \emph {dst}. Pointers are specified as a one to one mapping from source to destination, using the name of the pointer. Sets allow for pointer containment. All objects contain a \emph {name} attribute of type \emph {string}, not shown for clarity. Note: the meta-model is used to create the ROSMOD Modeling Language, but users do not see or interact with it; it is used to enforce proper model creation semantics. \relax }}{95}{figure.30}
\contentsline {figure}{\numberline {31}{\ignorespaces Workspace Code Generation. In this figure, the \emph {image\_processor} package and its children messages (red), components (blue), and services (purple) are generated into a catkin package for compilation. The msg and srv files are automatically filled out from the definitions of the messages and services, as are the header and source files for the components.\relax }}{102}{figure.31}
\contentsline {figure}{\numberline {32}{\ignorespaces Software Deployment Workflow\relax }}{104}{figure.32}
\contentsline {figure}{\numberline {33}{\ignorespaces Interpreting Execution Time Plots\relax }}{108}{figure.33}
\contentsline {figure}{\numberline {34}{\ignorespaces Experimental Observation: Client-Server Interactions\relax }}{109}{figure.34}
\contentsline {figure}{\numberline {35}{\ignorespaces CPN Analysis Results: Client-Server Interactions\relax }}{110}{figure.35}
\contentsline {figure}{\numberline {36}{\ignorespaces CPN Analysis Results: Client-Server Response Times in Bad Designs\relax }}{111}{figure.36}
\contentsline {figure}{\numberline {37}{\ignorespaces Experimental Observation: Publish-Subscribe Interactions\relax }}{112}{figure.37}
\contentsline {figure}{\numberline {38}{\ignorespaces CPN Analysis Results: Publish-Subscribe Interactions\relax }}{113}{figure.38}
\contentsline {figure}{\numberline {39}{\ignorespaces CPN Analysis Results: Time-triggered Publisher -- Periodicity Issues\relax }}{114}{figure.39}
\contentsline {figure}{\numberline {40}{\ignorespaces Trajectory Planner Test\relax }}{115}{figure.40}
\contentsline {figure}{\numberline {41}{\ignorespaces Experimental Observation: Trajectory Planner\relax }}{116}{figure.41}
\contentsline {figure}{\numberline {42}{\ignorespaces CPN Analysis Results: Trajectory Planner\relax }}{117}{figure.42}
\contentsline {figure}{\numberline {43}{\ignorespaces CPN Analysis - Sensor firing too frequently\relax }}{118}{figure.43}
\contentsline {figure}{\numberline {44}{\ignorespaces Experimental Observation: Periodic Timers\relax }}{119}{figure.44}
\contentsline {figure}{\numberline {45}{\ignorespaces CPN Analysis Results: Periodic Timers\relax }}{120}{figure.45}
\contentsline {figure}{\numberline {46}{\ignorespaces Long Running Operations - Timing Diagram\relax }}{122}{figure.46}
\contentsline {figure}{\numberline {47}{\ignorespaces Long Running Operation - Software Model\relax }}{123}{figure.47}
\contentsline {figure}{\numberline {48}{\ignorespaces Experimental Observation: Composed Component Assembly\relax }}{124}{figure.48}
\contentsline {figure}{\numberline {49}{\ignorespaces CPN Analysis Results: Composed Component Assembly\relax }}{125}{figure.49}
\addvspace {10\p@ }
\addvspace {10\p@ }
