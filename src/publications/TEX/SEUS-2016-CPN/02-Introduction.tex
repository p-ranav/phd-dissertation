\section{Introduction}

Developing efficient and reliable component-based software for large-scale distributed embedded systems is difficult. The widespread adoption of component-based software engineering has not only improved the maintainability of large complex code bases but also enabled structured analysis methods that rely on the principle of \emph{compositionality} \cite{jifeng2005component}: properties of a composed system can be derived from the properties of its components and connections. In prior work \cite{kumar2014colored}, we have considered one specific component model, DREMS (\emph{Distributed Real-time Embedded Managed Systems}) \cite{DREMS13Software}, and developed a Colored Petri net-based (CPN) \cite{CPN} timing analysis approach to model the structural and behavioral semantics of DREMS components, and presented various state space analysis techniques that can be applied to verify and analyze the timing properties of a composed system e.g. lack of deadline violations deadlocks etc. More recently, we have also presented \cite{SEUS} analysis improvements by leveraging structural reduction techniques and advanced state space generation methods that make our analysis model more scalable and relevant for industrial scale scenarios. 

Experimentally validating our timing analysis results is an important and necessary requirement. In order to obtain any level of confidence in our CPN-based work, the system design model needs to be completely implemented, and deployed on the target hardware platform. We have constructed an experimental embedded systems testbed \cite{kumarTestbed} to simulate and analyze resilient cyber-physical systems -- consisting of 32 \emph{Beaglebone Black} (BBB) development boards\footnote{BeagleBone Black Embedded Board: http://beagleboard.org/BLACK/}. We have chosen the light-weight \emph{Robot Operating System} (ROS) \cite{ROS} middleware layer and implemented a DREMS-style component model, ROSMOD \cite{kumarROSMOD}. Our goal with this work is to (1) develop a set of distributed component-based applications, (2) translate this design model to our CPN analysis model, (3) deploy these applications on our testbed and accurately measure operation execution times, and finally (4) perform state space analysis on the generated CPN model to check for conservative results, compared against the real system execution.

Our contributions in this paper are as follows:

\begin{enumerate}
	\item We present our evaluation workflow, including our hardware testbed, software deployment framework, and various real-time system properties that were enforced.
	\item We present a few component assemblies and interaction patterns, including the integration of long running operations, executed on our \emph{Resilient Cyber-Physical Systems} (RCPS) testbed and discuss operational performance with execution time plots.
	\item We describe how hardware-dependent metrics such as worst-case execution times propagate into our Colored Petri net-based analysis model. This is required in order to establish any level of consistency between the real system and its theoretical execution model.
	\item We present representative execution plots derived from our CPN, specifically plots of the worst execution trace realized during state space analysis. Comparing the real-world execution plots against our CPN analysis plots shows that our analysis results are conservative but close approximations of the real system execution.
\end{enumerate}

The remainder of this paper is organized as follows: Section \ref{sec:Related-Research} presents related research, reviewing and comparing existing analysis tools and formal methods. Section \ref{sec:ROSMOD} describes the operation execution semantics for our component model, presenting the need for our timing analysis methods. Section \ref{sec:CPN} briefly summarizes our Colored Petri net-based analysis model in order to establish the level of refinement involved. Section \ref{sec:Testbed} presents our experimental testbed, briefly describing the architecture and evaluation workflow.  Section \ref{sec:experiments} describes our experimental evaluation, presenting execution time plots of different interaction patterns and component assemblies. Finally Sections \ref{sec:Future-Work} and \ref{sec:Conclusions} briefly mention our planned future work and concluding remarks. 

%The rest of this paper is organized as follows. Section \ref{sec:Related_Research} presents related research, reviewing and comparing existing analysis tools and formal methods. Sections \ref{sec:Target_System_Architecture} briefly describes the DREMS architecture, specifically the concepts of interest that are covered by the timing analysis tool. Section \ref{sec:Modeling} describes the business logic modeling approach to capture the operational behavior of components in the application. Section \ref{sec:Analysis} describes the analysis improvements we were able to achieve with structural changes to the analysis model. This section also briefly describes the application of advanced state space analysis methods that enable efficient state space searches while reducing the state space size and overall memory consumption. Section \ref{sec:Future_Work} evaluates possible extensions to this work before concluding with Section \ref{sec:Conclusions}.