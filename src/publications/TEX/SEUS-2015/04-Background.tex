\section{Background}
\label{sec:Target_System_Architecture}
The target architecture for timing analysis is \emph{DREMS} \cite{ISIS_F6_Aerospace:12,DREMS13Software}. DREMS was designed and developed for a class of distributed real-time embedded systems that are remotely managed and have strict timing requirements. DREMS is a software infrastructure for the design, implementation, deployment, and management of component-based real-time embedded systems. The infrastructure includes design-time modeling tools \cite{ISIS_F6_SFFMT:13} that integrate with a well-defined and fully implemented component model \cite{ISIS_F6_ISORC:13, MoDeVVa} used to build component-based applications. Rapid prototyping and code generation features coupled with a modular run-time platform automate tedious aspects of software development and enable robust deployment and operation of mixed-criticality distributed applications. The formal modeling and analysis method presented in this paper focuses on applications built using this foundational architecture.

\subsection{Component Operations Scheduler}

DREMS applications are built by assembling and composing re-useable units of functionality called \emph{components}. Each component is characterized by a (1) set of communication ports, a (2) set of interfaces (accessed through ports), a (3) message queue, (4) timers and state variables. Components interact via publish/subscribe and synchronous or asynchronous remote method invocation (RMI and AMI) services provided by the middleware. Each component interface exposes one or more \emph{operations} that can be invoked due to the arrival of a message or a method invocation or the expiration of a timer. Every operation request coming from an external entity reaches the component through its message queue. This is a priority queue maintained by a component-level scheduler that schedules operations for execution. When ready, a single \emph{component executor thread} per component will be released to execute the operation requested by the front of the component's message queue. The operation runs to completion, hence component execution is always single-threaded. Note however that the multiple components \emph{can} be executed concurrently. 


\subsection{Operating System Scheduler}
DREMS components are grouped into processes that may be assigned to ARINC-653 \cite{ARINC-653} styled temporal partitions, implemented by the DREMS operating system scheduler. Temporal partitions are periodic, fixed intervals of the CPU's time. Threads associated with a partition are scheduled only when the partition is active. This enforces a temporal isolation between threads assigned to different partitions and assigns a guaranteed slice of the CPU's time to that partition. The repeating partition windows are called \emph{minor frames}. The aggregate of minor frames is called a \emph{major frame}. The duration of each major frame is called the \emph{hyperperiod}, which is typically the lowest common multiple of the partition periods. Each minor frame is characterized by a period and a duration. The duration of a partition defines the amount of time available per hyperperiod to schedule all threads assigned to that partition. Each \emph{node} in a network runs an OS scheduler, and the temporal partitions of the nodes are assumed to be synchronized, i.e. all hyperperiods start at the same time. 

\subsection{Colored Petri Nets}
Petri Nets \cite{Murata1989} are a graphical modeling tool used for describing and analyzing a wide range of systems. A Petri net is a five-tuple $(P, T, A, W, M_0)$ where $P$ is a finite set of places, $T$ is a finite set of transitions, $A$ is a finite set of arcs between places and transitions, $W$ is a function assigning weights to arcs, and $M_0$ is the initial marking of the net. Places hold a discrete number of markings called tokens. Tokens often represent resources in the modeled system. A transition can legally fire when all of its input places have necessary number of tokens. 

With Colored Petri Nets (CPN) \cite{CPN}, tokens contain values of specific data types called \emph{colors}. Transitions in CPN are enabled for firing only when valid colored tokens are present in all of the typed input places, and valid arc bindings are realized to produce the necessary colored tokens on output places. The firing of transitions in CPN can check for and modify the data values of these colored tokens. Furthermore, large and complex models can be constructed by composing smaller sub-models as CPN allows for hierarchical description.

\subsubsection{The Choice of Colored Petri Nets}
One of the primary reasons for choosing Colored Petri Nets over other high-level Petri Nets such as Timed Petri Nets or other modeling paradigms like timed automata is because of the powerful modeling concept made available by token colors. Each colored token can be a heterogeneous data structure such as a \emph{record} that can contain an arbitrary number of fields. This enables modeling within a single \emph{color-set} (C-style \texttt{struct}) system properties such as temporal partitioning, component interaction patterns, and even distributed deployment. The token colors can be inspected, modified, and manipulated by the occurring transitions and the arc bindings. Component properties such as thread priority, port connections and real-time requirements can be easily encoded into a single colored token, making the model considerably concise. In Section \ref{sec:Analysis}, we will discuss in more detail how some of the modeling concepts/changes we have made affect and improve the efficiency of analysis.