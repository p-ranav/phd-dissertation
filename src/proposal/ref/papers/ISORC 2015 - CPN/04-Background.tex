\section{Target System Architecture}
\label{sec:Target_System_Architecture}
The target architecture for timing analysis is \emph{DREMS} \cite{ISIS_F6_Aerospace:12,DREMS13Software}. DREMS is a software infrastructure for the design, implementation, deployment, and management of component-based real-time embedded systems. The infrastructure includes (1) design-time modeling tools \cite{ISIS_F6_SFFMT:13} that integrate with a well-defined (2) component model \cite{ISIS_F6_ISORC:13, MoDeVVa} used to build component-based applications. Rapid prototyping and code generation features coupled with a modular run-time platform automate tedious aspects of software development and enable robust deployment and operation of mixed-criticality distributed applications. The formal modeling and analysis method presented in this paper focuses on applications built using this foundational architecture. We emphasize here the importance of a component model: it defines a model of computation with a strict component execution semantics. 

\subsection{Component Operations Scheduler}

DREMS applications are built by assembling and composing re-useable units of functionality called \emph{Components}. Each component is characterized by a (1) set of communication ports, a (2) set of interfaces (accessed through ports), a (3) message queue, (4) timers and state variables. Components interact via publish/subscribe and synchronous or asynchronous remote method invocation (RMI and AMI) patterns. Each component interface exposes one or more \emph{operations} that can be invoked. Every operation request coming from an external entity reaches the component through its message queue. This is a priority-based queue maintained by a component-level scheduler that schedules operations for execution. When ready, a single \emph{component executor thread} per component will be released to execute the operation requested by the front of the component's message queue. The operation runs to completion, hence component execution is always single-threaded. Note however that the multiple components \emph{can} be executed concurrently. 


\subsection{Operating System Scheduler}
DREMS components are grouped into processes that are assigned to ARINC-653 \cite{ARINC-653} styled temporal partitions, implemented by the DREMS OS scheduler. Temporal partitions are periodic, fixed intervals of the CPU's time. Threads associated with a partition are scheduled only when the partition is active. This enforces a temporal isolation between threads assigned to different partitions and assigns a guaranteed slice of the CPU's time to that partition. The repeating partition windows are called \emph{minor frames}. The aggregate of minor frames is called a \emph{major frame}. The duration of each major frame is called the \emph{hyperperiod}, which is typically the lowest common multiple of the partition periods. Each minor frame is characterized by a period and a duration. The duration of a partition defines the amount of time available per hyperperiod to schedule all threads assigned to that partition. Each \emph{node} in a network runs an OS scheduler, and the temporal partitions of the nodes are assumed to be synchronized, i.e. all hyperperiods start at the same time. 

\subsection{Colored Petri Nets}

Petri nets \cite{Murata1989} are a graphical modeling tool used for describing and analyzing a wide range of systems. A Petri net is a five-tuple $(P, T, A, W, M_0)$ where $P$ is a finite set of places, $T$ is a finite set of transitions, $A$ is a finite set of arcs between places and transitions, $W$ is a function assigning weights to arcs, and $M_0$ is the initial marking of the net. Places hold a discrete number of markings called tokens. Tokens often represent resources in the modeled system. A transition can legally fire when all of its input places have necessary number of tokens. 
% Simplify...
%Since Petri net tokens are not distinguishable, the obtained model is often too complex for large systems. To enable compact representations for the modeled system, extensions to the basic Petri net model, called high-level Petri nets, are preferred.
With Colored Petri nets (CPN) \cite{CPN}, tokens contain values of specific data types called \emph{colors}. Transitions in CPN are enabled for firing only when valid colored tokens are present in all of the typed input places, and valid arc bindings are realized to produce the necessary colored tokens on output places. The firing of transitions in CPN can check for and modify the data values of these colored tokens. Furthermore, large and complex models can be constructed by composing smaller sub-models as CPN allows for hierarchical description. %This extended paradigm can more easily model and analyze systems with typed parameters. 


\section{Analysis Challenges}
\label{sec:Challenges}

There are certain implicit design complexities in DREMS that motivate our modeling and analysis approach.
\subsection{Operation Deadlines}
\label{subsec:Operation_Deadlines}
For each component the executor thread, when released by the component-level scheduler, runs under the control of the (fine-grain) OS scheduler. Each component executor thread has a fixed priority, assigned at design-time. However, the deadline for it is determined by the operation it executes, maintained at a higher level of abstraction. Therefore, depending on the operation executed by the executor thread, its timing requirements vary.

\subsection{WCET of Operations}
The execution of component operations serve the various periodic or aperiodic interaction requests from either the underlying framework or other connected (possibly distributed) components. Each operation is written by an application developer as a sequence of execution \emph{steps}. Each step could execute a unique set of tasks, e.g. perform a local calculation or a library call, initiate an interaction with another component, process a response from external entities, and it can have data-dependent, possibly looping control flow, etc. The behavior derived by the combination of these steps dictates the WCET of the component operation. This behavior includes non-deterministic delays that are caused by components communicating through a (1) time-varying network (2) using specific interaction patterns and (3) within the constraints of temporally partitioned execution. 

%System architectures like DREMS require an analysis tool with an expressive language that is tightly coupled with the target software platform (like our component model) to efficiently model and verify behavioral aspects of the system such as operational modes, the OS scheduling and distributed communication. Another crucial need for safety-critical systems is incorporating the timing analysis in every stage of the design. This firstly requires an analysis tool that can work with the non-determinism realized by incomplete designs. Secondly, this also requires the timing specifications and model transformations to be integrated into the design-time modeling. All of these aspects motivated us to choose colored Petri nets as the formalism to capture the various domain-specific properties and perform efficient timing analysis.

